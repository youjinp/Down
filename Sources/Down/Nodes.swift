//
//  File.swift
//  
//
//  Created by Youjin Phea on 15/05/21.
//

import Foundation
import cmark

// MARK: CMarkNode
// MARK: - CMarkNode
public typealias CMarkNode = UnsafeMutablePointer<cmark_node>

public extension CMarkNode {
    func wrap() -> Node {
        switch type {
        case CMARK_NODE_DOCUMENT:       return Document(cmarkNode: self)
        case CMARK_NODE_BLOCK_QUOTE:    return BlockQuote(cmarkNode: self)
        case CMARK_NODE_LIST:           return List(cmarkNode: self)
        case CMARK_NODE_ITEM:           return Item(cmarkNode: self)
        case CMARK_NODE_CODE_BLOCK:     return CodeBlock(cmarkNode: self)
        case CMARK_NODE_HTML_BLOCK:     return HtmlBlock(cmarkNode: self)
        case CMARK_NODE_CUSTOM_BLOCK:   return CustomBlock(cmarkNode: self)
        case CMARK_NODE_PARAGRAPH:      return Paragraph(cmarkNode: self)
        case CMARK_NODE_HEADING:        return Heading(cmarkNode: self)
        case CMARK_NODE_THEMATIC_BREAK: return ThematicBreak(cmarkNode: self)
        case CMARK_NODE_TEXT:           return Text(cmarkNode: self)
        case CMARK_NODE_SOFTBREAK:      return SoftBreak(cmarkNode: self)
        case CMARK_NODE_LINEBREAK:      return LineBreak(cmarkNode: self)
        case CMARK_NODE_CODE:           return Code(cmarkNode: self)
        case CMARK_NODE_HTML_INLINE:    return HtmlInline(cmarkNode: self)
        case CMARK_NODE_CUSTOM_INLINE:  return CustomInline(cmarkNode: self)
        case CMARK_NODE_EMPH:           return Emphasis(cmarkNode: self)
        case CMARK_NODE_STRONG:         return Strong(cmarkNode: self)
        case CMARK_NODE_LINK:           return Link(cmarkNode: self)
        case CMARK_NODE_IMAGE:          return Image(cmarkNode: self)
        default:                        fatalError("unsupported node")
        }
    }
    
    // MARK: Wrap properties
    var parent: CMarkNode? {
        return cmark_node_parent(self)
    }

    var type: cmark_node_type {
        return cmark_node_get_type(self)
    }

    var literal: String? {
        return String(cString: cmark_node_get_literal(self))
    }

    var fenceInfo: String? {
        return String(cString: cmark_node_get_fence_info(self))
    }

    var headingLevel: Int {
        return Int(cmark_node_get_heading_level(self))
    }

    var listType: cmark_list_type {
        return cmark_node_get_list_type(self)
    }

    var listStart: Int {
        return Int(cmark_node_get_list_start(self))
    }

    var url: String? {
        return String(cString: cmark_node_get_url(self))
    }

    var title: String? {
        return String(cString: cmark_node_get_title(self))
    }
}











// MARK: - Node
/**
 * A node is a wrapper of a raw `CMarkNode` belonging to the abstract syntax tree
 * generated by cmark.
 */
public class Node {

    public let cmarkNode: CMarkNode
    public private(set) lazy var children: [Node] = Array(childSequence)

    public private(set) lazy var nestDepth: Int = {
        var depth = 0
        var next = cmarkNode.parent

        while let current = next {
            depth += current.type == cmarkNode.type ? 1 : 0
            next = current.parent
        }
        return depth
    }()

    
    
    
    
    // MARK: Init
    init(cmarkNode: CMarkNode) {
        self.cmarkNode = cmarkNode
    }
    
    
    
    
    // MARK: API
    public func render<T: Renderer>(with renderer: T, options: DownOptions, width: Int32) throws -> T.Result {
        return try renderer.render(self.cmarkNode, options: options, width: width)
    }
    
    /**
     * True if the node has a sibling that succeeds it.
     */
    var hasSuccessor: Bool {
        return cmark_node_next(cmarkNode) != nil
    }

    /**
     * Sequence of wrapped child nodes.
     */
    var childSequence: ChildSequence {
        return ChildSequence(node: cmarkNode)
    }
}





/**
 * Sequence of child nodes.
 */
public struct ChildSequence: Sequence {

    // MARK: Properties
    let node: CMarkNode

    // MARK: Methods
    public func makeIterator() -> Iterator {
        return Iterator(node: cmark_node_first_child(node))
    }

    public struct Iterator: IteratorProtocol {

        // MARK: Properties
        var node: CMarkNode?

        // MARK: Methods
        public mutating func next() -> Node? {
            guard let node = node else { return nil }
            defer { self.node = cmark_node_next(node) }

            return node.wrap()
        }
    }
}








// MARK: - Document
public class Document: Node, CustomDebugStringConvertible {

    deinit {
        cmark_node_free(cmarkNode)
    }

    public var debugDescription: String {
        return "Document"
    }
}


// MARK: - BlockQuote
public class BlockQuote: Node, CustomDebugStringConvertible {
    public var debugDescription: String {
        return "Block Quote"
    }
}





// MARK: - Code
public class Code: Node, CustomDebugStringConvertible {
    /**
     * The code content, if present.
     */
    public private(set) lazy var literal: String? = cmarkNode.literal

    public var debugDescription: String {
        return "Code - \(literal ?? "nil")"
    }
}






// MARK: - CodeBlock
public class CodeBlock: Node, CustomDebugStringConvertible {

    // MARK: Properties

    /**
    * The code content, if present.
     */
    public private(set) lazy var literal: String? = cmarkNode.literal

    /**
     * The fence info is an optional string that trails the opening sequence of backticks.
     * It can be used to provide some contextual information about the block, such as
     * the name of a programming language.
     *
     * For example:
     * ```
     * '''<fence info>
     * <literal>
     * '''
     * ```
     *
     */
    public private(set) lazy var fenceInfo: String? = cmarkNode.fenceInfo

    public var debugDescription: String {
        let content = (literal ?? "nil").replacingOccurrences(of: "\n", with: "\\n")
        return "Code Block - fenceInfo: \(fenceInfo ?? "nil"), content: \(content)"
    }
}






// MARK: - CustomBlock
public class CustomBlock: Node, CustomDebugStringConvertible {
    /**
     * The custom content, if present.
     */
    public private(set) lazy var literal: String? = cmarkNode.literal

    public var debugDescription: String {
        return "Custom Block - \(literal ?? "nil")"
    }
}






// MARK: - CustomInline
public class CustomInline: Node, CustomDebugStringConvertible {
    /**
     * The custom content, if present.
     */
    public private(set) lazy var literal: String? = cmarkNode.literal
    
    public var debugDescription: String {
        return "Custom Inline - \(literal ?? "nil")"
    }
}





// MARK: - Emphasis
public class Emphasis: Node, CustomDebugStringConvertible {
    public var debugDescription: String {
        return "Emphasis"
    }
}






// MARK: - Heading
public class Heading: Node, CustomDebugStringConvertible {
    /**
     * The level of the heading, a value between 1 and 6.
     */
    public private(set) lazy var headingLevel: Int = cmarkNode.headingLevel
    
    public var debugDescription: String {
        return "Heading - L\(headingLevel)"
    }
}





// MARK: - HTMLBlock
public class HtmlBlock: Node, CustomDebugStringConvertible {
    /**
     * The html content, if present.
     */
    public private(set) lazy var literal: String? = cmarkNode.literal

    public var debugDescription: String {
        let content = (literal ?? "nil").replacingOccurrences(of: "\n", with: "\\n")
        return "Html Block - content: \(content)"
    }
}





// MARK: - HTMLInline
public class HtmlInline: Node, CustomDebugStringConvertible {
    /**
     * The html tag, if present.
     */
    public private(set) lazy var literal: String? = cmarkNode.literal
    
    public var debugDescription: String {
        return "Html Inline - \(literal ?? "nil")"
    }
}





// MARK: - Image
public class Image: Node, CustomDebugStringConvertible {
    /**
     * The title of the image, if present.
     *
     * In the example below, the first line is a reference link, with the reference at the
     * bottom. `<text>` is literal text belonging to children nodes. The title occurs
     * after the url and is optional.
     *
     * ```
     * ![<text>][<id>]
     * ...
     * [<id>]: <url> "<title>"
     * ```
     */
    public private(set) lazy var title: String? = cmarkNode.title

    /**
     * The url of the image, if present.
     *
     * For example:
     *
     * ```
     * ![<text>](<url>)
     * ```
     */
    public private(set) lazy var url: String? = cmarkNode.url
    
    public var debugDescription: String {
        return "Image - title: \(title ?? "nil"), url: \(url ?? "nil"))"
    }
}






// MARK: - Item
public class Item: Node, CustomDebugStringConvertible {
    public var debugDescription: String {
        return "Item"
    }
}






// MARK: - LineBreak
public class LineBreak: Node, CustomDebugStringConvertible {
    public var debugDescription: String {
        return "Line Break"
    }
}






// MARK: - Link
public class Link: Node, CustomDebugStringConvertible {

    /**
     * The title of the link, if present.
     *
     * In the example below, the first line is a reference link, with the reference at the
     * bottom. `<text>` is literal text belonging to children nodes. The title occurs
     * after the url and is optional.
     *
     * ```
     * [<text>][<id>]
     * ...
     * [<id>]: <url> "<title>"
     * ```
     */
    public private(set) lazy var title: String? = cmarkNode.title

    /**
     * The url of the link, if present.
     *
     * For example:
     *
     * ```
     * [<text>](<url>)
     * ```
     */
    public private(set) lazy var url: String? = cmarkNode.url

    public var debugDescription: String {
        return "Link - title: \(title ?? "nil"), url: \(url ?? "nil"))"
    }
}






// MARK: - List
public class List: Node, CustomDebugStringConvertible {

    /**
     * The type of the list, either bullet or ordered.
     */
    public lazy var listType: ListType = {
        guard let type = ListType(cmarkNode: cmarkNode) else {
            assertionFailure("Unsupported or missing list type. Defaulting to .bullet.")
            return .bullet
        }

        return type
    }()

    /**
     * The number of items in the list.
     */
    public lazy var numberOfItems: Int = children.count

    /**
     * Whether the list is "tight".
     *
     * If any of the list items are separated by a blank line, then this property is `false`. This value is
     * a hint to render the list with more (loose) or less (tight) spacing between items.
     */
    public lazy var isTight: Bool = cmark_node_get_list_tight(cmarkNode) == 1

    public enum ListType: CustomDebugStringConvertible {
        case bullet
        case ordered(start: Int)

        public var debugDescription: String {
            switch self {
            case .bullet: return "Bullet"
            case .ordered(let start): return "Ordered (start: \(start))"
            }
        }

        init?(cmarkNode: CMarkNode) {
            switch cmarkNode.listType {
            case CMARK_BULLET_LIST: self = .bullet
            case CMARK_ORDERED_LIST: self = .ordered(start: cmarkNode.listStart)
            default: return nil
            }
        }
    }
    
    public var debugDescription: String {
        return "List - type: \(listType), isTight: \(isTight)"
    }
}





// MARK: - Paragraph
public class Paragraph: Node, CustomDebugStringConvertible {
    public var debugDescription: String {
        return "Paragraph"
    }
}





// MARK: - SoftBreak
public class SoftBreak: Node, CustomDebugStringConvertible {
    public var debugDescription: String {
        return "Soft Break"
    }
}





// MARK: - Strong
public class Strong: Node, CustomDebugStringConvertible {
    public var debugDescription: String {
        return "Strong"
    }
}





// MARK: - Text
public class Text: Node, CustomDebugStringConvertible {
    /**
     * The text content, if present.
     */
    public private(set) lazy var literal: String? = cmarkNode.literal

    public var debugDescription: String {
        return "Text - \(literal ?? "nil")"
    }
}





// MARK: - ThematicBreak
public class ThematicBreak: Node, CustomDebugStringConvertible {
    public var debugDescription: String {
        return "Thematic Break"
    }
}
